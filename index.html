<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<title>mountain theater</title>
		<style>
			html, body, canvas { margin: 0; padding: 0; border: 0; overflow: hidden; }
			body { background: #034; }
			canvas { width: 100vw; height: 100vh; }
		</style>
	</head>
	<body>
		<script src="js/webvr-polyfill.js"></script>
		<script src="js/three.js"></script>
		<script src="js/TerrainLoader.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script>

			// setup
			var webvrPolyfill = new WebVRPolyfill();

			// user data
			var sea_color = 0x003344;
			var rock_color = 0x6F7953;
			var sky_color = 0x1c6ba0;

			var south_lat = 46;
			var north_lat = 49;
			var west_lng = -121;
			var east_lng = -126;
			
			var tile_name = "geodata/terrain-n"+south_lat+"-n"+north_lat+",w"+Math.abs(east_lng)+"-w"+Math.abs(west_lng)+".envi";

			var here_lat = 47.677756; // degrees
			var here_lng = -122.338935; // degrees
			var here_alt_above_ground = 10; // meters
			var meters_per_degree = 111111;
			var meters_per_degree_x = meters_per_degree;
			var meters_per_degree_z = Math.cos(here_lat * 3.1416 * 2 / 360) * meters_per_degree;

			var CUTOFF_DISTANCE = 1400; // meters

			var scene = new THREE.Scene();

			var here_x = here_lng * meters_per_degree_x;
			var here_z = here_lat * meters_per_degree_z;

			scene.background = new THREE.Color(sky_color);
			scene.fog = new THREE.Fog(0xaaaabb, 0.1, CUTOFF_DISTANCE);

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			// Also inspire by https://threejs.org/examples/webgl_shaders_sky.html
			// Get NREL SPA azimuth and inclination.  https://www.nrel.gov/docs/fy08osti/34302.pdf
			var sunlight = new THREE.DirectionalLight(0xfae25f, 0.7);
			sunlight.position.set(50, 20, 0);
			scene.add(sunlight);

			var helper = new THREE.DirectionalLightHelper(sunlight, 2);
			scene.add(helper);

			var mat = new THREE.MeshBasicMaterial({ color: sea_color, side: THREE.DoubleSide });
			var seaLevel = new THREE.Mesh(new THREE.PlaneBufferGeometry(2000, 2000, 8, 8), mat);
			seaLevel.rotateX( - Math.PI / 2);
			scene.add(seaLevel);

			var height_coefficient = 35;

			var ground_material = new THREE.MeshPhongMaterial({ color: rock_color, shininess: 0.20, specular: 0xffffff, wireframe: false });

			var info_xhr = new XMLHttpRequest();
			var terrainLoader = new THREE.TerrainLoader();
			terrainLoader.load(tile_name, function(data) {
				console.debug("Got " + data.length + " uint16s of elevation data.");

				info_xhr.open("GET", tile_name+".aux.xml", true);
				info_xhr.onload = function (e) {
					if (info_xhr.readyState === 4) {
						console.debug("Got the auxxml");
						var lines = info_xhr.responseXML.querySelectorAll('MDI[key=lines]')[0].textContent-1;
						var samples = info_xhr.responseXML.querySelectorAll('MDI[key=samples]')[0].textContent-1;

						var ground_geometry = new THREE.PlaneGeometry(samples*10, lines*10, samples, lines);

						if (ground_geometry.vertices.length != data.length) {
							console.error("aborting: vertex count: " + ground_geometry.vertices.length);
							console.error("aborting: data count: " + data.length);
							return;
						}

						for (var i = 0, l = data.length; i < l; i++) {
							  ground_geometry.vertices[i].z = data[i] * height_coefficient / 65535;
						}

						var ground_plane = new THREE.Mesh(ground_geometry, ground_material);
						ground_plane.rotateX( - Math.PI / 2);
						ground_plane.translateZ(-0.3); // submerge the sea level
						scene.add(ground_plane);
						
					}
				};
				info_xhr.send(false);
			});


			var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 2, CUTOFF_DISTANCE);
			camera.position.y = here_alt_above_ground;
			camera.position.x = here_x;
			camera.position.z = here_z;

			var controls = new THREE.OrbitControls(camera);

			//controls.update() must be called after any manual changes to the camera's transform
			camera.position.set(0, 20, 100);
			//controls.enableDamping = true;
			controls.enableKeys = true;
			//controls.maxPolarAngle = 0;
			controls.rotateSpeed = 1;
			controls.update();

			function animate() {
				requestAnimationFrame(animate);
				// required if controls.enableDamping or controls.autoRotate are set to true
				//controls.update();
				renderer.render(scene, camera);
			}
			animate();

		</script>
	</body>
</html>
<!-- vim: set shiftwidth=2 tabstop=2 : -->
